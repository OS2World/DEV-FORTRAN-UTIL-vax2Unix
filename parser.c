
/*  A Bison parser, made from parser.y
    by bison 1.28  */

#define YYBISON 1  /* Identify Bison output.  */

#define	END_OF_STATEMENT	257
#define	IGNORE_THIS_TOKEN	258
#define	INCLUDE_T	259
#define	FORMAT_STATEMENT	260
#define	PASS_STATEMENT_T	261
#define	OPEN_STATEMENT_T	262
#define	IO_STATEMENT	263
#define	PASS_TEXT	264
#define	EQUALS	265
#define	INTEGER_CONSTANT	266
#define	REAL_CONSTANT	267
#define	L_PAREN	268
#define	R_PAREN	269
#define	COMMENT_STATEMENT_OUT	270
#define	IF_STATEMENT	271
#define	IF_THEN_STATEMENT	272
#define	ENCODE_DECODE	273
#define	ELSE_IF_STATEMENT	274
#define	RELATIONAL_OP_T	275
#define	IF_ARGUEMENT	276
#define	THEN_T	277
#define	ELSE_STATEMENT	278
#define	STRING_START	279
#define	STRING_ELEMENT	280
#define	END_OF_PROGRAM	281
#define	BYTE_TYPE	282
#define	LOGICAL_TYPE	283
#define	INTEGER_TYPE	284
#define	REAL_TYPE	285
#define	DOUBLE_TYPE	286
#define	COMPLEX_TYPE	287
#define	DOUBLE_COMPLEX_TYPE	288
#define	CHARACTER_TYPE	289
#define	OPEN_PASS	290
#define	OPEN_DUMP	291
#define	DO_STATEMENT	292
#define	END_DO_STATEMENT	293
#define	END_IF_STATEMENT	294
#define	GOTO_STATEMENT	295
#define	COMPUTED_GOTO_STATEMENT	296
#define	COMMON_STATEMENT	297
#define	INTRINSIC_OR_EXTERN_STATEMENT	298
#define	VARIABLE_NAME	299
#define	IO_PARAM_NAME	300
#define	STAR	301
#define	UNIT_IDENT	302
#define	APOS	303
#define	QUOTE	304
#define	COLON	305
#define	REFERENCE	306
#define	SPECIFICATION_COMPLETE	307
#define	CONCAT	308
#define	IMPLICIT_STATEMENT	309
#define	EQUIVALENCE_STATEMENT	310
#define	DIMENSION_STATEMENT	311
#define	FUNCTION	312
#define	SUBROUTINE	313
#define	NAMELIST	314
#define	PARAMETER	315
#define	DATA	316
#define	CALL	317
#define	CHAR	318
#define	DASH	319
#define	SLASH	320
#define	DOT	321
#define	GLOBAL_FUNCTION	322
#define	GLOBAL_SUBROUTINE	323
#define	GLOBAL_COMMON	324
#define	LOGICAL_OP	325
#define	LOGICAL_NOT	326
#define	ADD_OP	327
#define	MUL_OP	328
#define	EXP_OP	329
#define	COMMA	330
#define	LAST_DEFINED_TOKEN	331


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <ctype.h>

#include "convert.h"
#include "userHeap.h"
#include "convertUtils.h"
#include "symbolManagement.h"

#define EXTERN
#include "externalVariables.h"

#define OLD_PROC 0

extern SYMBOL_LIST_CONTROL	globalCommon;
extern SYMBOL_LIST_CONTROL	procedureList;

/*	See the comments in setProcedureToken for an explanation of the
	nest three variables  */
static YACC_SYMBOL	*currentProcedureToken;
static int			procedureDeclarationPending;
static VARIABLE_DEFINITION			*pcurrentArgVar;

#define NP (void *)0
/* macro SAP - SetArithProperties */
#define SAP(a,b) a->arithType=b->arithType;a->arithSize=b->arithSize;
#define MAX_DO_NEST_LEVEL 50
/*  PAT means Propagate Arithmetic Type.  It is used to express
    the type of a result of an arithmetic operation.  */
	#define PAT(d,l,r) d->arithType = max (l->arithType, r->arithType); \
	        d->arithSize = max (l->arithSize, r->arithSize);


static void ignoreStatement (void);
static void	includeFromLibrary (char	*baseName);
static void initParser (void);
static int popDoLevel (void);
static void processBinaryOp (YACC_SYMBOL *l, YACC_SYMBOL *op, YACC_SYMBOL *r);
static void processUnaryOp (YACC_SYMBOL *op, YACC_SYMBOL *r);	
static void pushDoLevel (int statementNo);
static void setProcedureToken (YACC_SYMBOL *proc, YACC_SYMBOL *arg);
static void testAlternateReturn (YACC_SYMBOL *pys);
static void __yy_bcopy (char *from, char *to, int count);
void yyerror (char *msg);


static int	doNestLevel;
static int	doEndStack[MAX_DO_NEST_LEVEL];

FILE 		*errorFile;
char		*currentFileName;
static int			ifArgIsArithmetic;
static YACC_SYMBOL	*nonkeyRecordNumber;

void endOfStatementProc ( YACC_SYMBOL *topToken);
int			forlex (void);
int			yylex (void);
int			yyparse (void);

typedef union	{
	YACC_SYMBOL		*ysym;
	int				intVal;
	} YYSTYPE;
#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		538
#define	YYFLAG		-32768
#define	YYNTBASE	78

#define YYTRANSLATE(x) ((unsigned)(x) <= 331 ? yytranslate[x] : 174)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,
    77
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     1,     4,     6,     8,    10,    12,    14,    16,    18,
    20,    22,    24,    26,    28,    30,    32,    34,    36,    38,
    40,    42,    44,    46,    48,    50,    52,    54,    56,    58,
    60,    62,    64,    66,    69,    71,    80,    83,    87,    89,
    93,    97,   103,   105,   108,   113,   120,   126,   128,   131,
   137,   141,   144,   152,   156,   160,   164,   168,   170,   172,
   176,   180,   182,   184,   187,   190,   193,   196,   200,   205,
   207,   209,   211,   213,   217,   221,   225,   228,   230,   233,
   237,   239,   250,   260,   262,   264,   266,   272,   278,   280,
   282,   284,   287,   291,   294,   297,   300,   303,   307,   312,
   316,   319,   323,   327,   331,   335,   342,   350,   355,   359,
   364,   368,   370,   373,   376,   380,   383,   387,   389,   392,
   394,   398,   402,   407,   410,   414,   419,   424,   428,   434,
   441,   447,   449,   451,   454,   457,   460,   465,   469,   473,
   477,   481,   484,   488,   492,   494,   496,   498,   502,   506,
   510,   514,   518,   520,   522,   524,   526,   528,   530,   534,
   537,   539,   541,   544,   551,   557,   563,   570,   576,   582,
   584,   586,   588,   592,   594,   596,   598,   600,   602,   604,
   606,   608,   611,   615,   617,   621,   626,   628,   632,   634,
   638,   642,   644,   648,   654,   660,   664,   669,   673,   679,
   681,   685,   687,   689,   693,   695,   699,   704,   706,   710,
   712,   716,   718,   720,   724,   728,   731,   734,   738,   740,
   744,   746,   751,   753,   755,   759,   763,   769,   775,   777,
   781,   783,   787,   789,   791,   793,   795,   799,   804,   809,
   813,   815,   818,   822,   826,   828,   830,   832,   836,   840,
   845,   847,   852,   856,   858,   862,   868,   870,   874,   876,
   878,   880,   882,   889,   893,   899,   903,   906,   910,   914,
   919,   923,   927,   933,   937,   943,   947,   953,   958,   963,
   968,   972,   976,   981
};

static const short yyrhs[] = {    -1,
    78,    79,     0,   111,     0,   112,     0,    97,     0,   102,
     0,   106,     0,    89,     0,    90,     0,    95,     0,    96,
     0,   130,     0,   128,     0,   155,     0,   142,     0,   131,
     0,   136,     0,   148,     0,   138,     0,   160,     0,   165,
     0,   166,     0,   169,     0,   173,     0,   172,     0,    80,
     0,    85,     0,    86,     0,   113,     0,   115,     0,   116,
     0,    27,     0,     3,     0,     1,     3,     0,    53,     0,
    68,    45,    47,    45,    47,    84,    81,     3,     0,    14,
    15,     0,    14,    82,    15,     0,    83,     0,    82,    76,
    83,     0,    45,    47,    84,     0,    83,    51,    12,    47,
    12,     0,    12,     0,    73,    12,     0,    69,    45,    81,
     3,     0,    70,    66,    45,    66,    87,     3,     0,    70,
    66,    66,    87,     3,     0,    88,     0,    87,    88,     0,
    45,    47,    12,    47,    12,     0,     7,   117,     3,     0,
     7,     3,     0,    91,    12,    76,    12,    76,    12,     3,
     0,    91,    23,     3,     0,    91,   117,     3,     0,    92,
    94,    15,     0,    92,    93,    15,     0,    17,     0,    20,
     0,    94,    21,    94,     0,    93,    21,    94,     0,    22,
     0,   124,     0,    94,   124,     0,    94,    22,     0,    24,
     3,     0,    16,     3,     0,    16,   117,     3,     0,     8,
    98,    15,     3,     0,    99,     0,   101,     0,    12,     0,
   100,     0,    99,    76,   101,     0,    99,    76,    12,     0,
    99,    76,   100,     0,    37,   117,     0,    37,     0,    36,
   117,     0,    36,   117,    50,     0,    36,     0,    19,    14,
   121,    76,   103,    76,   104,    15,   117,     3,     0,    19,
    14,   121,    76,   103,    76,   104,    15,     3,     0,    12,
     0,    45,     0,   105,     0,   104,    76,    45,    11,    45,
     0,   104,    76,    45,    11,    12,     0,    45,     0,   120,
     0,   126,     0,   107,     3,     0,   107,   117,     3,     0,
   108,    15,     0,   109,    15,     0,     9,   121,     0,     9,
    74,     0,   108,    76,    74,     0,     9,   121,    49,   121,
     0,   108,    76,   121,     0,     9,   110,     0,   109,    76,
   110,     0,   108,    76,   110,     0,    46,    11,   117,     0,
    46,    11,   124,     0,     5,    14,    10,    15,    50,     3,
     0,     5,   117,    14,    10,    15,    50,     3,     0,     5,
    10,    50,     3,     0,     6,   117,     3,     0,    38,   114,
   117,     3,     0,    38,   117,     3,     0,    12,     0,    12,
    76,     0,    39,     3,     0,    39,   117,     3,     0,    40,
     3,     0,    40,   117,     3,     0,    10,     0,   117,    10,
     0,   121,     0,   118,    76,   121,     0,   118,    76,    76,
     0,   118,    76,    76,   121,     0,    76,    76,     0,    76,
    76,   121,     0,    52,    14,   121,    15,     0,    45,    14,
   118,    15,     0,    45,    14,    15,     0,    45,    14,    76,
   118,    15,     0,    45,    14,    76,   118,    76,    15,     0,
    45,    14,   118,    76,    15,     0,    45,     0,   120,     0,
   123,    45,     0,   123,   120,     0,   123,   127,     0,   123,
    14,   121,    15,     0,    14,   121,    15,     0,   121,    73,
   121,     0,   121,    74,   121,     0,   121,    71,   121,     0,
    72,   121,     0,   121,    75,   121,     0,   121,    54,   121,
     0,   122,     0,   127,     0,   119,     0,    45,    67,    45,
     0,   122,    67,    45,     0,   120,    67,    45,     0,   120,
    67,   120,     0,    45,    67,   120,     0,    73,     0,    74,
     0,    66,     0,    47,     0,    75,     0,    54,     0,    25,
   125,    49,     0,    25,    49,     0,   126,     0,    26,     0,
   125,    26,     0,    45,    14,   121,    51,   121,    15,     0,
    45,    14,    51,   121,    15,     0,    45,    14,   121,    51,
    15,     0,   120,    14,   121,    51,   121,    15,     0,   120,
    14,    51,   121,    15,     0,   120,    14,   121,    51,    15,
     0,    12,     0,   124,     0,    13,     0,    42,   117,     3,
     0,    28,     0,    29,     0,    30,     0,    31,     0,    32,
     0,    33,     0,    34,     0,    35,     0,    41,     3,     0,
    55,   132,     3,     0,   133,     0,   132,    76,   133,     0,
   137,    14,   134,    15,     0,   135,     0,   135,    76,   135,
     0,    64,     0,    64,    65,    64,     0,    44,   163,     3,
     0,   129,     0,   129,    47,    12,     0,   129,    47,    14,
   121,    15,     0,   129,    47,    14,    47,    15,     0,    56,
   139,     3,     0,    56,    76,   139,     3,     0,    14,   140,
    15,     0,   139,    76,    14,   140,    15,     0,   141,     0,
   140,    76,   141,     0,    45,     0,   144,     0,    57,   143,
     3,     0,   144,     0,   143,    76,   144,     0,    45,    14,
   145,    15,     0,   146,     0,   145,    76,   146,     0,   147,
     0,   147,    51,   147,     0,    12,     0,    45,     0,   147,
   123,    12,     0,   147,   123,    45,     0,    73,    12,     0,
    73,    45,     0,   137,   149,     3,     0,   150,     0,   149,
    76,   150,     0,   151,     0,   151,    66,   152,    66,     0,
    45,     0,   144,     0,   144,    47,    12,     0,    45,    47,
    12,     0,    45,    47,    14,   121,    15,     0,    45,    47,
    14,    47,    15,     0,   153,     0,   152,    76,   153,     0,
   154,     0,   154,    47,   154,     0,    45,     0,    12,     0,
    13,     0,   124,     0,    43,   157,     3,     0,    43,   159,
   157,     3,     0,    66,    45,    66,   158,     0,    66,    66,
   158,     0,   156,     0,   157,   156,     0,   157,    76,   156,
     0,   157,    76,   158,     0,    45,     0,   144,     0,   158,
     0,   159,    76,   158,     0,    58,   161,     3,     0,   137,
    58,   161,     3,     0,   162,     0,   162,    14,   163,    15,
     0,   162,    14,    15,     0,    45,     0,    45,    47,    12,
     0,    45,    47,    14,    47,    15,     0,   164,     0,   163,
    76,   164,     0,    45,     0,    47,     0,   120,     0,   122,
     0,    59,    45,    14,   163,    15,     3,     0,    59,    45,
     3,     0,    59,    45,    14,    15,     3,     0,    60,   167,
     3,     0,   168,    45,     0,   167,    76,    45,     0,   167,
   168,    45,     0,   167,    76,   168,    45,     0,    66,    45,
    66,     0,    61,   171,     3,     0,    61,    14,   170,    15,
     3,     0,    45,    11,   121,     0,   170,    76,    45,    11,
   121,     0,    45,    11,   121,     0,   171,    76,    45,    11,
   121,     0,    45,    11,   121,     3,     0,   126,    11,   121,
     3,     0,   120,    11,   121,     3,     0,    63,   120,     3,
     0,    63,    45,     3,     0,   122,    11,   121,     3,     0,
    62,   117,     3,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   159,   160,   162,   163,   164,   165,   166,   167,   168,   169,
   170,   171,   172,   173,   174,   175,   176,   177,   178,   179,
   180,   181,   182,   183,   184,   185,   186,   187,   188,   191,
   195,   199,   208,   209,   210,   218,   230,   234,   237,   238,
   252,   267,   294,   295,   300,   311,   316,   322,   323,   327,
   340,   342,   347,   350,   359,   366,   370,   376,   377,   380,
   382,   386,   387,   388,   390,   394,   396,   397,   401,   406,
   407,   409,   411,   413,   415,   417,   420,   421,   424,   426,
   428,   431,   435,   440,   441,   443,   444,   446,   450,   451,
   452,   455,   456,   460,   470,   474,   478,   480,   482,   486,
   490,   494,   496,   500,   502,   506,   524,   543,   558,   561,
   566,   570,   571,   574,   575,   578,   579,   583,   584,   587,
   589,   593,   597,   602,   606,   613,   625,   630,   634,   643,
   652,   663,   668,   669,   675,   679,   683,   687,   691,   694,
   697,   699,   700,   703,   704,   705,   706,   709,   711,   713,
   715,   717,   720,   721,   722,   723,   724,   725,   728,   733,
   737,   743,   744,   750,   753,   755,   757,   760,   762,   767,
   769,   770,   773,   778,   782,   786,   790,   794,   798,   802,
   806,   812,   815,   819,   820,   824,   849,   850,   855,   859,
   864,   868,   872,   875,   879,   885,   887,   891,   893,   896,
   897,   901,   902,   905,   909,   910,   914,   925,   926,   942,
   946,   952,   953,   957,   960,   964,   968,   975,   985,   986,
   990,   991,   995,   996,   997,  1001,  1005,  1009,  1015,  1016,
  1020,  1021,  1025,  1026,  1027,  1028,  1032,  1036,  1042,  1044,
  1048,  1049,  1051,  1053,  1057,  1058,  1061,  1062,  1065,  1075,
  1086,  1091,  1096,  1103,  1104,  1108,  1114,  1115,  1120,  1126,
  1130,  1131,  1133,  1143,  1149,  1157,  1162,  1164,  1166,  1168,
  1172,  1175,  1179,  1185,  1189,  1195,  1200,  1207,  1209,  1211,
  1213,  1215,  1221,  1225
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const yytname[] = {   "$","error","$undefined.","END_OF_STATEMENT",
"IGNORE_THIS_TOKEN","INCLUDE_T","FORMAT_STATEMENT","PASS_STATEMENT_T","OPEN_STATEMENT_T",
"IO_STATEMENT","PASS_TEXT","EQUALS","INTEGER_CONSTANT","REAL_CONSTANT","L_PAREN",
"R_PAREN","COMMENT_STATEMENT_OUT","IF_STATEMENT","IF_THEN_STATEMENT","ENCODE_DECODE",
"ELSE_IF_STATEMENT","RELATIONAL_OP_T","IF_ARGUEMENT","THEN_T","ELSE_STATEMENT",
"STRING_START","STRING_ELEMENT","END_OF_PROGRAM","BYTE_TYPE","LOGICAL_TYPE",
"INTEGER_TYPE","REAL_TYPE","DOUBLE_TYPE","COMPLEX_TYPE","DOUBLE_COMPLEX_TYPE",
"CHARACTER_TYPE","OPEN_PASS","OPEN_DUMP","DO_STATEMENT","END_DO_STATEMENT","END_IF_STATEMENT",
"GOTO_STATEMENT","COMPUTED_GOTO_STATEMENT","COMMON_STATEMENT","INTRINSIC_OR_EXTERN_STATEMENT",
"VARIABLE_NAME","IO_PARAM_NAME","STAR","UNIT_IDENT","APOS","QUOTE","COLON","REFERENCE",
"SPECIFICATION_COMPLETE","CONCAT","IMPLICIT_STATEMENT","EQUIVALENCE_STATEMENT",
"DIMENSION_STATEMENT","FUNCTION","SUBROUTINE","NAMELIST","PARAMETER","DATA",
"CALL","CHAR","DASH","SLASH","DOT","GLOBAL_FUNCTION","GLOBAL_SUBROUTINE","GLOBAL_COMMON",
"LOGICAL_OP","LOGICAL_NOT","ADD_OP","MUL_OP","EXP_OP","COMMA","LAST_DEFINED_TOKEN",
"fake_statement","statement","global_function_statement","global_call_spec",
"global_arg_list","global_arg_item","signed_integer","global_subroutine_statement",
"global_common_statement","global_common_list","global_common_item","pass_statement",
"if_statement","base_if","if_statement_start","logical_arguement","if_arguement",
"else_statement","comment_statement_out","open_statement","open_arg2","open_arg",
"open_dump","open_pass","encode_decode_statement","format_spec","encode_optional",
"encode_optional2","io_statement","io_control_list","io_control_list_nonkey",
"io_control_list_key","io_param","include_statement","format_statement","do_statement",
"do_limit","end_do_statement","end_if_statement","pass_text","arg_list","variable_reference",
"paren_ref","expression","structure_ref","operation","string","string_element",
"substring","literal","computed_goto_statement","base_type","goto_statement",
"implicit_statement","implicit_specifier_list","implicit_specifier_item","implicit_specifier_code_list",
"implicit_specifier_code","intrinsic_or_extern_statement","type_specifier","equivalence_statement",
"equivalence_list","equivalence_group","equivalence_item","dimension_statement",
"array_list","array_declarator","dimension_list","dimension_element","dimension_atom",
"type_definition_statement","type_variable_list","extended_type_variable_item",
"type_variable_item","value_list","value_element","value_atom","common_statement",
"common_block_name","common_block_list","common_item","common_item_list","function_statement",
"base_function_spec","base_function_name","variable_list","variable_list_element",
"subroutine_statement","namelist_statement","namelist_list","namelist_group",
"parameter_statement","parameter_list","vax_parameter_list","arithmetic_statement",
"data_statement", NULL
};
#endif

static const short yyr1[] = {     0,
    78,    78,    79,    79,    79,    79,    79,    79,    79,    79,
    79,    79,    79,    79,    79,    79,    79,    79,    79,    79,
    79,    79,    79,    79,    79,    79,    79,    79,    79,    79,
    79,    79,    79,    79,    79,    80,    81,    81,    82,    82,
    83,    83,    84,    84,    85,    86,    86,    87,    87,    88,
    89,    89,    90,    90,    90,    91,    91,    92,    92,    93,
    93,    94,    94,    94,    94,    95,    96,    96,    97,    98,
    99,    99,    99,    99,    99,    99,   100,   100,   101,   101,
   101,   102,   102,   103,   103,   104,   104,   104,   105,   105,
   105,   106,   106,   107,   107,   108,   108,   108,   108,   108,
   109,   109,   109,   110,   110,   111,   111,   111,   112,   113,
   113,   114,   114,   115,   115,   116,   116,   117,   117,   118,
   118,   118,   118,   118,   118,   119,   120,   120,   120,   120,
   120,   121,   121,   121,   121,   121,   121,   121,   121,   121,
   121,   121,   121,   121,   121,   121,   121,   122,   122,   122,
   122,   122,   123,   123,   123,   123,   123,   123,   124,   124,
   124,   125,   125,   126,   126,   126,   126,   126,   126,   127,
   127,   127,   128,   129,   129,   129,   129,   129,   129,   129,
   129,   130,   131,   132,   132,   133,   134,   134,   135,   135,
   136,   137,   137,   137,   137,   138,   138,   139,   139,   140,
   140,   141,   141,   142,   143,   143,   144,   145,   145,   146,
   146,   147,   147,   147,   147,   147,   147,   148,   149,   149,
   150,   150,   151,   151,   151,   151,   151,   151,   152,   152,
   153,   153,   154,   154,   154,   154,   155,   155,   156,   156,
   157,   157,   157,   157,   158,   158,   159,   159,   160,   160,
   161,   161,   161,   162,   162,   162,   163,   163,   164,   164,
   164,   164,   165,   165,   165,   166,   167,   167,   167,   167,
   168,   169,   169,   170,   170,   171,   171,   172,   172,   172,
   172,   172,   172,   173
};

static const short yyr2[] = {     0,
     0,     2,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     2,     1,     8,     2,     3,     1,     3,
     3,     5,     1,     2,     4,     6,     5,     1,     2,     5,
     3,     2,     7,     3,     3,     3,     3,     1,     1,     3,
     3,     1,     1,     2,     2,     2,     2,     3,     4,     1,
     1,     1,     1,     3,     3,     3,     2,     1,     2,     3,
     1,    10,     9,     1,     1,     1,     5,     5,     1,     1,
     1,     2,     3,     2,     2,     2,     2,     3,     4,     3,
     2,     3,     3,     3,     3,     6,     7,     4,     3,     4,
     3,     1,     2,     2,     3,     2,     3,     1,     2,     1,
     3,     3,     4,     2,     3,     4,     4,     3,     5,     6,
     5,     1,     1,     2,     2,     2,     4,     3,     3,     3,
     3,     2,     3,     3,     1,     1,     1,     3,     3,     3,
     3,     3,     1,     1,     1,     1,     1,     1,     3,     2,
     1,     1,     2,     6,     5,     5,     6,     5,     5,     1,
     1,     1,     3,     1,     1,     1,     1,     1,     1,     1,
     1,     2,     3,     1,     3,     4,     1,     3,     1,     3,
     3,     1,     3,     5,     5,     3,     4,     3,     5,     1,
     3,     1,     1,     3,     1,     3,     4,     1,     3,     1,
     3,     1,     1,     3,     3,     2,     2,     3,     1,     3,
     1,     4,     1,     1,     3,     3,     5,     5,     1,     3,
     1,     3,     1,     1,     1,     1,     3,     4,     4,     3,
     1,     2,     3,     3,     1,     1,     1,     3,     3,     4,
     1,     4,     3,     1,     3,     5,     1,     3,     1,     1,
     1,     1,     6,     3,     5,     3,     2,     3,     3,     4,
     3,     3,     5,     3,     5,     3,     5,     4,     4,     4,
     3,     3,     4,     3
};

static const short yydefact[] = {     1,
     0,     0,    33,     0,     0,     0,     0,     0,     0,    58,
     0,    59,     0,    32,   174,   175,   176,   177,   178,   179,
   180,   181,     0,     0,     0,     0,     0,     0,     0,     0,
    35,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     2,    26,    27,    28,     8,     9,     0,
     0,    10,    11,     5,     6,     7,     0,     0,     0,     3,
     4,    29,    30,    31,     0,     0,     0,    13,   192,    12,
    16,    17,     0,    19,    15,    18,    14,    20,    21,    22,
    23,    25,    24,    34,   118,     0,     0,   118,     0,    52,
     0,    72,    81,    78,     0,    70,    73,    71,   170,   172,
     0,     0,   132,     0,   156,     0,   158,   155,     0,   153,
   154,   157,   101,   147,   133,    96,   145,     0,   171,   161,
   146,    67,     0,     0,    66,   112,     0,     0,   114,     0,
   116,     0,   182,     0,   245,     0,   246,   241,     0,   247,
     0,   259,   260,   261,   262,     0,   257,     0,     0,     0,
     0,   184,     0,     0,     0,     0,     0,     0,   205,   254,
     0,   251,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,    62,     0,
     0,     0,     0,    63,    92,     0,    94,     0,    95,     0,
     0,     0,     0,     0,     0,     0,     0,   223,     0,   224,
     0,   219,   221,     0,     0,   119,     0,   109,    51,    79,
    77,     0,     0,   154,     0,   162,   160,     0,     0,     0,
   142,     0,     0,     0,     0,     0,     0,     0,   134,   135,
   136,    68,     0,   113,     0,   111,   115,   117,   173,     0,
     0,     0,   237,     0,   242,     0,     0,     0,   191,     0,
     0,   128,     0,     0,     0,   120,   148,   152,   183,     0,
     0,   202,     0,   200,   203,     0,   196,     0,   204,     0,
     0,   249,     0,   264,     0,     0,   266,     0,     0,   267,
     0,     0,     0,   272,     0,   284,   282,   281,     0,     0,
     0,     0,     0,     0,    54,    55,    57,     0,    56,     0,
    65,    64,    93,   154,   103,   100,   102,     0,     0,     0,
   150,   151,     0,   149,     0,   193,     0,     0,     0,     0,
   218,     0,     0,   108,     0,     0,    80,    69,    75,    76,
    74,   138,   163,   159,   104,   105,     0,    99,   144,   141,
   139,   140,   143,     0,     0,   110,   212,   213,     0,     0,
   208,   210,     0,   240,   243,   244,   248,   238,   120,   258,
   278,     0,   124,     0,   127,     0,     0,   185,   189,     0,
   187,   198,     0,   197,     0,   206,   255,     0,   253,     0,
     0,     0,   271,   268,     0,   269,     0,     0,     0,   276,
     0,     0,    37,     0,     0,    39,    45,     0,     0,     0,
    48,     0,    61,    60,   280,     0,     0,   283,   279,   156,
     0,   226,     0,   250,   225,   220,   234,   235,   233,   236,
     0,   229,   231,     0,     0,   126,   137,    84,    85,     0,
   216,   217,   207,     0,     0,     0,   239,   165,   124,   125,
   129,     0,   131,   122,   121,   166,     0,     0,   186,     0,
   201,     0,     0,   252,   265,     0,   270,   274,   273,     0,
     0,     0,     0,    38,     0,     0,     0,     0,    47,    49,
     0,   168,   169,     0,   195,   194,   156,     0,   222,     0,
     0,   106,     0,     0,   209,   211,   214,   215,   130,   123,
   164,   190,   188,   199,   256,   263,     0,   277,    43,     0,
     0,    41,    40,     0,    46,     0,     0,   167,   228,   227,
   230,   232,   107,    89,     0,    86,    90,    91,   275,    44,
     0,     0,     0,    53,     0,     0,    36,    42,    50,    83,
     0,     0,    82,     0,    88,    87,     0,     0
};

static const short yydefgoto[] = {     1,
    44,    45,   291,   395,   396,   501,    46,    47,   400,   401,
    48,    49,    50,    51,   181,   182,    52,    53,    54,    95,
    96,    97,    98,    55,   430,   515,   516,    56,    57,    58,
    59,   113,    60,    61,    62,   127,    63,    64,    87,   255,
   114,   115,   359,   117,   118,   119,   218,   120,   121,    68,
    69,    70,    71,   151,   152,   370,   371,    72,   153,    74,
   156,   263,   264,    75,   158,   137,   350,   351,   352,    76,
   201,   202,   203,   421,   422,   423,    77,   138,   139,   140,
   141,    78,   161,   162,   146,   147,    79,    80,   165,   166,
    81,   282,   169,    82,    83
};

static const short yypact[] = {-32768,
   448,    33,-32768,   249,    41,    62,   143,   585,   248,-32768,
   164,-32768,    53,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,   327,   319,   325,   167,    41,   -13,   314,    60,
-32768,   392,    17,   162,   173,   188,     3,    40,    41,   197,
   212,   231,   117,-32768,-32768,-32768,-32768,-32768,-32768,    50,
    16,-32768,-32768,-32768,-32768,-32768,   348,    42,    44,-32768,
-32768,-32768,-32768,-32768,   136,    28,   190,-32768,   202,-32768,
-32768,-32768,    -8,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,   232,   297,   335,-32768,   379,-32768,
   380,-32768,    41,    41,   352,   317,-32768,-32768,-32768,-32768,
   759,   141,   138,   313,-32768,   365,-32768,-32768,   759,-32768,
    63,-32768,-32768,-32768,   145,   490,   273,   241,-32768,-32768,
-32768,-32768,   405,   759,-32768,   322,    41,   406,-32768,   425,
-32768,   427,-32768,   435,   371,     2,-32768,-32768,    11,-32768,
   250,   148,-32768,   350,   273,    20,-32768,   759,   223,   389,
    21,-32768,   436,   415,   447,    23,   371,    24,-32768,   424,
   471,   470,   264,   457,    14,   489,   493,   531,    25,   437,
   309,   543,   501,   535,     4,   474,   556,   449,-32768,   554,
   154,   366,   557,-32768,-32768,   459,-32768,   636,-32768,   534,
   759,   640,   540,   759,   541,   759,   432,    32,   173,   546,
    26,-32768,   528,   593,   586,-32768,   592,-32768,-32768,   150,
   595,   600,   204,-32768,   156,-32768,-32768,   146,    38,   759,
   458,   759,   759,   759,   759,   759,   759,   759,   554,   557,
-32768,-32768,   326,-32768,   460,-32768,-32768,-32768,-32768,    31,
   542,   561,-32768,   -13,-32768,   561,    18,   296,-32768,   314,
    37,-32768,   759,   280,    66,   622,   602,-32768,-32768,   392,
   550,   371,    77,-32768,-32768,    27,-32768,   604,-32768,   162,
   486,-32768,   272,-32768,   286,   555,-32768,   166,   575,-32768,
   612,    90,   759,-32768,   580,-32768,-32768,-32768,   584,   183,
   630,   568,   590,   626,-32768,-32768,-32768,    16,-32768,    16,
-32768,-32768,-32768,    92,-32768,   538,-32768,    55,   759,   653,
   602,-32768,    61,-32768,    83,-32768,   774,   509,   637,   629,
-32768,   610,   151,-32768,   597,   641,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,   595,-32768,   172,   538,   538,   458,
   339,   587,   587,   198,   137,-32768,-32768,-32768,   139,    98,
-32768,   553,   561,-32768,-32768,-32768,-32768,-32768,   538,-32768,
-32768,   229,   570,   101,-32768,   500,   704,-32768,   598,   649,
   591,-32768,   415,-32768,   415,-32768,-32768,   619,-32768,   110,
   665,   116,-32768,-32768,   624,-32768,   759,   667,   627,   538,
   660,   628,-32768,   631,   123,   623,-32768,   590,   632,    22,
-32768,   601,   239,   239,-32768,   303,   708,-32768,-32768,   669,
   321,-32768,   810,-32768,-32768,-32768,-32768,-32768,   554,-32768,
   254,-32768,   633,   683,   639,-32768,-32768,-32768,-32768,   625,
-32768,-32768,-32768,    31,    31,   149,-32768,-32768,   759,   538,
-32768,   515,-32768,   759,   538,-32768,   332,   634,-32768,   550,
-32768,   126,   684,-32768,-32768,   697,-32768,   538,-32768,   692,
   759,   131,   131,-32768,   680,   693,    30,   718,-32768,-32768,
   719,-32768,-32768,   358,-32768,-32768,   717,   482,-32768,   151,
   151,-32768,   731,   690,-32768,   504,-32768,-32768,-32768,   538,
-32768,-32768,-32768,-32768,-32768,-32768,   759,   538,-32768,   724,
   535,-32768,   623,   691,-32768,   694,   734,-32768,-32768,-32768,
-32768,-32768,-32768,   554,   133,-32768,   557,-32768,   538,-32768,
   736,   728,   730,-32768,   463,   698,-32768,-32768,-32768,-32768,
   516,   733,-32768,   161,-32768,-32768,   745,-32768
};

static const short yypgoto[] = {-32768,
-32768,-32768,   245,-32768,   282,   285,-32768,-32768,   354,  -385,
-32768,-32768,-32768,-32768,-32768,   224,-32768,-32768,-32768,-32768,
-32768,   537,   544,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   347,-32768,-32768,-32768,-32768,-32768,-32768,    -5,   505,
-32768,    15,    -3,     6,  -346,   -38,-32768,     1,   643,-32768,
-32768,-32768,-32768,-32768,   494,-32768,   315,-32768,   762,-32768,
   609,   391,   394,-32768,-32768,   -31,-32768,   334,   340,-32768,
-32768,   467,-32768,-32768,   289,   304,-32768,  -130,   650,  -234,
-32768,-32768,   594,-32768,   268,   545,-32768,-32768,-32768,  -154,
-32768,-32768,-32768,-32768,-32768
};


#define	YYLAST		885


static const short yytable[] = {    89,
    91,    67,   159,   123,   116,   436,    66,   354,   245,   356,
   279,   357,   184,   243,   470,    65,   277,   128,   130,   132,
   358,   134,   249,   259,   469,   267,   269,   284,   321,   374,
   154,   135,   505,   170,   145,    84,   198,   179,   194,   361,
   102,   200,   347,   144,   178,   240,   241,    88,   292,   199,
    88,   186,   136,   167,   172,   125,   187,   405,   189,    88,
   180,   176,   102,   408,    90,   183,   399,   242,   164,   293,
   148,    88,   177,   149,   399,   348,   136,   -97,   318,   164,
   365,   470,   180,   136,   168,   409,   244,   210,   211,   278,
   223,   372,   155,   244,   195,   250,   260,   215,   268,   270,
   285,   322,   268,   349,   388,   221,   -98,   224,   223,   225,
   226,   227,   433,   355,   223,   441,   245,   188,   437,   190,
   233,   235,   265,   385,   454,   224,   150,   225,   226,   227,
   456,   224,   230,   225,   226,   227,   223,   464,   -97,   436,
   494,   366,   499,   302,   251,   256,   191,   525,   428,   192,
   431,   149,   373,   224,    92,   225,   226,   227,   192,   206,
   487,   248,   417,   418,   258,   389,   216,   -98,   297,   133,
   332,   333,   535,   434,   298,   102,   442,   124,    93,    94,
   336,   429,   175,   432,   306,   250,   426,   308,   310,   217,
   313,   250,   315,   488,   334,   419,   183,   393,   465,   327,
   196,   373,   193,   500,   150,   536,   157,   312,   526,   223,
   384,   193,   427,   335,   150,   329,   337,   160,   338,   339,
   340,   341,   342,   343,   344,   223,   224,   394,   225,   226,
   227,   164,   163,   183,    99,   100,   101,   252,   376,    93,
    94,   171,   224,   438,   225,   226,   227,   102,   197,   362,
   122,   223,    99,   100,   228,   145,   173,    88,    85,   184,
   301,   184,    86,   102,   144,   102,   274,   103,   224,   105,
   225,   226,   227,   253,   106,   174,   107,   275,   145,   390,
   145,   204,   223,   180,   420,   229,   379,   144,   108,   144,
   200,    99,   100,   101,   109,   110,   214,   112,   254,   224,
   381,   225,   226,   227,   102,   406,   205,    99,   100,   101,
   252,   287,   183,   411,   183,   136,   142,   472,   143,   479,
   102,   129,   248,   219,   103,   246,   105,   131,    88,   480,
   142,   106,   143,   107,    88,   476,    88,   183,   126,   195,
   103,   265,   105,   265,   206,   108,   491,   106,   207,   107,
   185,   109,   110,   214,   112,   363,   223,    88,   142,   440,
   143,   108,   445,   447,   302,   302,   212,   109,   110,   214,
   112,   254,   508,   224,   223,   225,   226,   227,   220,   223,
   299,   208,   209,   458,   240,   223,   300,   301,   206,   206,
   102,   224,   213,   225,   226,   227,   224,   234,   225,   226,
   227,   345,   224,   474,   225,   226,   227,   232,   236,   478,
   180,   223,   226,   227,   206,   206,   193,   183,   183,    15,
    16,    17,    18,    19,    20,    21,    22,   237,   224,   238,
   225,   226,   227,   257,   206,   440,   206,   239,   445,   286,
   490,   420,   420,   316,   206,   317,   206,   537,     2,   261,
     3,   296,     4,     5,     6,     7,     8,   498,   206,   262,
   154,   303,   346,     9,    10,   530,    11,    12,   206,   206,
   271,    13,    88,   272,    14,    15,    16,    17,    18,    19,
    20,    21,    22,   273,   518,    23,    24,    25,    26,    27,
    28,    29,    30,   519,   183,   183,   510,   377,   517,   378,
    31,   276,    32,    33,    34,    35,    36,    37,    38,    39,
    40,    99,   100,   101,   443,    41,    42,    43,   533,   531,
   412,   403,   413,   404,   102,   206,    99,   100,   101,   489,
   225,   226,   227,   280,   305,   223,   307,   281,   222,   102,
   380,   283,   382,   223,   103,   288,   105,   289,   290,   294,
   105,   106,   224,   107,   225,   226,   227,   107,   295,   103,
   224,   105,   225,   226,   227,   108,   106,   149,   107,   108,
   192,   109,   110,   214,   112,   444,   110,   214,   112,   104,
   108,    99,   100,   101,   311,   314,   109,   110,   214,   112,
   444,   223,   320,   323,   102,   324,    99,   100,   101,   105,
   325,   326,   328,   435,   206,   135,   107,   353,   224,   102,
   225,   226,   227,   369,   103,   248,   105,   375,   108,   386,
   383,   106,   387,   107,   391,   110,   214,   112,   392,   103,
   104,   105,   397,   398,   399,   108,   106,   402,   107,   414,
   415,   109,   110,   214,   112,   439,   424,    99,   100,   101,
   108,    99,   100,   101,   198,   425,   109,   110,   111,   112,
   102,   227,   448,   449,   102,   453,   450,   455,   457,   459,
   461,   460,   367,   466,   462,   223,   471,   463,   468,   481,
   103,   104,   105,   475,   103,   482,   105,   106,   483,   107,
   309,   106,   224,   107,   225,   226,   227,   492,   495,   496,
   484,   108,   497,   407,   504,   108,   223,   109,   110,   304,
   112,   109,   110,   214,   112,    99,   100,   101,   446,    99,
   100,   101,   473,   224,   394,   225,   226,   227,   102,   506,
   507,   509,   102,   513,   514,   520,   524,   522,   527,   528,
   523,   529,   532,   534,   538,   521,   503,   502,   103,   330,
   105,   467,   103,   368,   105,   106,   331,   107,   364,   106,
   231,   107,    73,   266,   493,   452,   451,   485,   511,   108,
    99,   100,   101,   108,   486,   109,   110,   214,   112,   109,
   110,   214,   112,   102,   512,    99,   100,   101,   416,     0,
   247,     0,   319,     0,   360,     0,     0,     0,   102,     0,
     0,     0,     0,   103,     0,   105,     0,     0,     0,     0,
   106,     0,   107,     0,     0,     0,     0,     0,   103,     0,
   410,    99,   100,   101,   108,   106,     0,   107,     0,     0,
   109,   110,   214,   112,   102,     0,     0,     0,     0,   108,
     0,     0,     0,     0,     0,   109,   110,   214,   112,     0,
     0,     0,     0,     0,   103,     0,   477,     0,     0,     0,
     0,   106,     0,   107,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   108,     0,     0,     0,     0,
     0,   109,   110,   214,   112
};

static const short yycheck[] = {     5,
     6,     1,    34,     9,     8,   352,     1,   242,   139,   244,
   165,   246,    51,     3,   400,     1,     3,    23,    24,    25,
     3,    27,     3,     3,     3,     3,     3,     3,     3,     3,
    14,    45,     3,    39,    29,     3,    45,    22,    11,     3,
    25,    73,    12,    29,    50,    14,    45,    10,    45,    58,
    10,    57,    66,    14,    40,     3,    15,     3,    15,    10,
    45,    12,    25,     3,     3,    51,    45,    66,    66,    66,
    11,    10,    23,    14,    45,    45,    66,    15,    47,    66,
    15,   467,    45,    66,    45,     3,    76,    93,    94,    76,
    54,    15,    76,    76,    67,    76,    76,   101,    76,    76,
    76,    76,    76,    73,    15,   109,    15,    71,    54,    73,
    74,    75,    15,   244,    54,    15,   247,    76,   353,    76,
   124,   127,   154,   278,    15,    71,    67,    73,    74,    75,
    15,    71,   118,    73,    74,    75,    54,    15,    76,   486,
    15,    76,    12,   182,   148,   149,    11,    15,    12,    14,
    12,    14,    76,    71,    12,    73,    74,    75,    14,    10,
    12,    14,    12,    13,   150,    76,    26,    76,    15,     3,
    15,    26,    12,    76,    21,    25,    76,    14,    36,    37,
   219,    45,    66,    45,   188,    76,    15,   191,   192,    49,
   194,    76,   196,    45,    49,    45,   182,    15,    76,    50,
    11,    76,    67,    73,    67,    45,    45,   193,    76,    54,
    45,    67,    15,   219,    67,    12,   220,    45,   222,   223,
   224,   225,   226,   227,   228,    54,    71,    45,    73,    74,
    75,    66,    45,   219,    12,    13,    14,    15,   270,    36,
    37,    45,    71,    15,    73,    74,    75,    25,    47,   253,
     3,    54,    12,    13,    14,   250,    45,    10,    10,   298,
    22,   300,    14,    25,   250,    25,     3,    45,    71,    47,
    73,    74,    75,    51,    52,    45,    54,    14,   273,   283,
   275,    50,    54,    45,   323,    45,    15,   273,    66,   275,
   322,    12,    13,    14,    72,    73,    74,    75,    76,    71,
    15,    73,    74,    75,    25,   309,    10,    12,    13,    14,
    15,     3,   298,   317,   300,    66,    45,    15,    47,    66,
    25,     3,    14,    11,    45,    76,    47,     3,    10,    76,
    45,    52,    47,    54,    10,    15,    10,   323,    12,    67,
    45,   373,    47,   375,    10,    66,    15,    52,    14,    54,
     3,    72,    73,    74,    75,    76,    54,    10,    45,   363,
    47,    66,   366,   367,   403,   404,    15,    72,    73,    74,
    75,    76,    15,    71,    54,    73,    74,    75,    14,    54,
    15,     3,     3,   387,    14,    54,    21,    22,    10,    10,
    25,    71,    76,    73,    74,    75,    71,    76,    73,    74,
    75,    76,    71,   407,    73,    74,    75,     3,     3,   413,
    45,    54,    74,    75,    10,    10,    67,   403,   404,    28,
    29,    30,    31,    32,    33,    34,    35,     3,    71,     3,
    73,    74,    75,    45,    10,   439,    10,     3,   442,     3,
   444,   480,   481,    12,    10,    14,    10,     0,     1,    14,
     3,     3,     5,     6,     7,     8,     9,   461,    10,    45,
    14,     3,     3,    16,    17,     3,    19,    20,    10,    10,
    47,    24,    10,     3,    27,    28,    29,    30,    31,    32,
    33,    34,    35,    14,   484,    38,    39,    40,    41,    42,
    43,    44,    45,   497,   480,   481,    15,    12,   484,    14,
    53,    45,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    12,    13,    14,    15,    68,    69,    70,     3,   525,
    12,   298,    14,   300,    25,    10,    12,    13,    14,    15,
    73,    74,    75,    45,   188,    54,   190,    45,    49,    25,
   273,    11,   275,    54,    45,     3,    47,    47,    14,    76,
    47,    52,    71,    54,    73,    74,    75,    54,     3,    45,
    71,    47,    73,    74,    75,    66,    52,    14,    54,    66,
    14,    72,    73,    74,    75,    76,    73,    74,    75,    46,
    66,    12,    13,    14,    45,    45,    72,    73,    74,    75,
    76,    54,    47,    66,    25,     3,    12,    13,    14,    47,
    15,    10,     3,    51,    10,    45,    54,    66,    71,    25,
    73,    74,    75,    64,    45,    14,    47,    14,    66,    45,
    66,    52,    11,    54,    45,    73,    74,    75,    45,    45,
    46,    47,     3,    66,    45,    66,    52,    12,    54,     3,
    12,    72,    73,    74,    75,    76,    50,    12,    13,    14,
    66,    12,    13,    14,    45,    15,    72,    73,    74,    75,
    25,    75,    65,    15,    25,    47,    76,     3,    45,     3,
    11,    45,    51,    51,    47,    54,    76,    47,    47,    47,
    45,    46,    47,    15,    45,     3,    47,    52,    50,    54,
    51,    52,    71,    54,    73,    74,    75,    64,    15,     3,
    76,    66,    11,    51,    12,    66,    54,    72,    73,    74,
    75,    72,    73,    74,    75,    12,    13,    14,    15,    12,
    13,    14,    15,    71,    45,    73,    74,    75,    25,    12,
    12,    15,    25,     3,    45,    12,     3,    47,     3,    12,
    47,    12,    45,    11,     0,   501,   465,   463,    45,   213,
    47,   398,    45,   260,    47,    52,   213,    54,   254,    52,
   118,    54,     1,   155,   450,   375,   373,   434,   480,    66,
    12,    13,    14,    66,   435,    72,    73,    74,    75,    72,
    73,    74,    75,    25,   481,    12,    13,    14,   322,    -1,
   141,    -1,   199,    -1,   250,    -1,    -1,    -1,    25,    -1,
    -1,    -1,    -1,    45,    -1,    47,    -1,    -1,    -1,    -1,
    52,    -1,    54,    -1,    -1,    -1,    -1,    -1,    45,    -1,
    47,    12,    13,    14,    66,    52,    -1,    54,    -1,    -1,
    72,    73,    74,    75,    25,    -1,    -1,    -1,    -1,    66,
    -1,    -1,    -1,    -1,    -1,    72,    73,    74,    75,    -1,
    -1,    -1,    -1,    -1,    45,    -1,    47,    -1,    -1,    -1,
    -1,    52,    -1,    54,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    66,    -1,    -1,    -1,    -1,
    -1,    72,    73,    74,    75
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */


/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */


#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#define YYLEX		yylex(&yylval, &yylloc)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif


int
yyparse()
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 1:
{ yyval.ysym = 0; ;
    break;}
case 2:
{yyval.ysym = yyvsp[0].ysym; ;
    break;}
case 3:
{ endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 4:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 5:
{ endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 6:
{ endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 7:
{ endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 8:
{ endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 9:
{endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 10:
{ endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 11:
{ endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 12:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 13:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 14:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 15:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 16:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 17:
{endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 18:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 19:
{endOfStatementProc (yyvsp[0].ysym); ;
    break;}
case 20:
{endOfStatementProc (yyvsp[0].ysym);  ;
    break;}
case 21:
{ endOfStatementProc (yyvsp[0].ysym);  ;
    break;}
case 22:
{ endOfStatementProc (yyvsp[0].ysym);  ;
    break;}
case 23:
{endOfStatementProc (yyvsp[0].ysym);  ;
    break;}
case 24:
{endOfStatementProc (yyvsp[0].ysym);  ;
    break;}
case 25:
{endOfStatementProc (yyvsp[0].ysym);  ;
    break;}
case 26:
{ignoreStatement (); ;
    break;}
case 27:
{ignoreStatement (); ;
    break;}
case 28:
{ignoreStatement (); ;
    break;}
case 29:
{
		++blockIndentLevel;
		endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 30:
{
		if (blockIndentLevel)
			--blockIndentLevel; 
		endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 31:
{
		if (blockIndentLevel)
			--blockIndentLevel; 
		endOfStatementProc (yyvsp[0].ysym);;
    break;}
case 32:
{ /* END_OF_PROGRAM */
		if (procedureDeclarationPending)
			{defineProcedure (currentProcedureToken, pcurrentArgVar);
			procedureDeclarationPending = 0;
			}
 		compareCommonBlocks ();
		initLexer (); 
		initParser ();
		endOfStatementProc (yyvsp[0].ysym);
    break;}
case 33:
{;
    break;}
case 34:
{fputs ("\n", yyout); fflush (yyout); ;
    break;}
case 35:
{
		if (procedureDeclarationPending)
			{defineProcedure (currentProcedureToken, pcurrentArgVar);
			procedureDeclarationPending = 0;
			}
		;
    break;}
case 36:
{VARIABLE_DEFINITION	*pvd;
		
		yyval.ysym = yyvsp[-7].ysym;
		pvd = addProcedure (yyvsp[-6].ysym, 0);
		pvd->argumentOrCommonLink = (void *)(yyvsp[-1].ysym->argListLink);
		pvd->type = ENVT_FUNCTION;
		pvd->arithType = yyvsp[-2].ysym->arithType;
		pvd->variableSize = yyvsp[-2].ysym->constantValue;
		;
    break;}
case 37:
{yyval.ysym = yyvsp[-1].ysym;
		yyval.ysym->argListLink = 0;
		;
    break;}
case 38:
{yyval.ysym = yyvsp[-2].ysym; yyval.ysym->argListLink = yyvsp[-1].ysym->argListLink;;
    break;}
case 40:
{/* link the current item to the end of the list */
		ARGUMENT_DEFINITION		**ppa,
								*pa;
		
		yyval.ysym = yyvsp[-2].ysym;
		pa = (ARGUMENT_DEFINITION *) (yyvsp[-2].ysym->argListLink);
		ppa = &(pa);
		while (pa->next)
			pa = pa->next;
		pa->next = (ARGUMENT_DEFINITION *) (yyvsp[0].ysym->argListLink);
		
		;
    break;}
case 41:
{ /* VARIABLE_NAME is the name of an arithmetic type eg, 
			INTEGER, REAL, etc.  signed_integer is the size of the variable
			*/
		
		ARGUMENT_DEFINITION		*parg;
	
		yyval.ysym = yyvsp[-2].ysym;
		parg = (ARGUMENT_DEFINITION *)allocProcedureMem (sizeof (ARGUMENT_DEFINITION) );
		yyval.ysym->argListLink = (YACC_SYMBOL *) parg;
		memset ( (void *)parg, 0, sizeof (ARGUMENT_DEFINITION) );
		parg->storageClass |= ENSC_DUMMY_VARIABLE;
		parg->arithType = yyvsp[-2].ysym->arithType;
		parg->arithSize = yyvsp[0].ysym->constantValue;
		;
    break;}
case 42:
{DIMENSION_DEFINITION	*pdd;
		DIMENSION_DEFINITION	*pdd2,
								*pdd3;
		ARGUMENT_DEFINITION		*parg;
		
		yyval.ysym = yyvsp[-4].ysym;
		/* The current argument is dimensioned - create a DIMENSION_DEFINITION */
		pdd = (DIMENSION_DEFINITION *) heapAlloc (&(procedureList.symbols),
				sizeof (DIMENSION_DEFINITION) );
		memset ( (void *)pdd, 0, sizeof (DIMENSION_DEFINITION) );
		pdd->size = yyvsp[-2].ysym->constantValue;
		pdd->lowerBound = yyvsp[0].ysym->constantValue;
		parg = (ARGUMENT_DEFINITION *)(yyvsp[-4].ysym->argListLink);
		/*	Link the new DIMENSION_DEFINITION to the end of the dimension
			list of the current argument */
		if (pdd2=parg->dimension)
			{while (pdd3 = (DIMENSION_DEFINITION *)(pdd2->nextDim) )
				pdd2 = pdd3;
			pdd2->nextDim = (DIMENSION_DEFINITION *)(pdd);
			}
		else
			parg->dimension = pdd;
		
		;
    break;}
case 44:
{ yyval.ysym = yyvsp[-1].ysym;
		processUnaryOp (yyvsp[-1].ysym, yyvsp[0].ysym);
		;
    break;}
case 45:
{VARIABLE_DEFINITION	*pvd;
		
		yyval.ysym = yyvsp[-3].ysym;
		pvd = addProcedure (yyvsp[-2].ysym, 0);
		pvd->argumentOrCommonLink = (void *) (yyvsp[-1].ysym->argListLink);
		pvd->type = ENVT_SUBROUTINE;
		;
    break;}
case 46:
{yyval.ysym = yyvsp[-5].ysym;
		processGlobalCommonBlock (yyvsp[-3].ysym->token, yyvsp[-1].ysym);
		;
    break;}
case 47:
{yyval.ysym = yyvsp[-4].ysym;
		processGlobalCommonBlock (0, yyvsp[-1].ysym);
		;
    break;}
case 49:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 50:
{COMMON_REGION		*pcr;
		
		yyval.ysym = yyvsp[-4].ysym;
		pcr = (COMMON_REGION *)heapAlloc (&(globalCommon.symbols),
			sizeof (COMMON_REGION) );
		pcr->type = yyvsp[-4].ysym->arithType;
		pcr->variableSize = yyvsp[-2].ysym->constantValue;
		pcr->variableCount = yyvsp[0].ysym->constantValue;
		pcr->next = 0;
		yyvsp[-4].ysym->argListLink = (YACC_SYMBOL *) pcr;
		;
    break;}
case 51:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 52:
{ ;
    break;}
case 53:
{joinSymbols (&yyval.ysym, yyvsp[-6].ysym, yyvsp[-5].ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
		;
    break;}
case 54:
{
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
		if (yyval.ysym->number != ELSE_IF_STATEMENT)
			{yyval.ysym->number = IF_THEN_STATEMENT;
			++blockIndentLevel;
			}
		makeLogicalIf (yyvsp[-2].ysym, ifArgIsArithmetic);
		;
    break;}
case 55:
{
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
		makeLogicalIf (yyvsp[-2].ysym, ifArgIsArithmetic);
		;
    break;}
case 56:
{ ifArgIsArithmetic = 1;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 57:
{ ifArgIsArithmetic = 0;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 60:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym,  NP); ;
    break;}
case 61:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym,  NP); ;
    break;}
case 64:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 65:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 68:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 69:
{ /* forming open statement */
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 71:
{ yyval.ysym = yyvsp[0].ysym;
    break;}
case 72:
{ yyval.ysym = yyvsp[0].ysym;
    break;}
case 73:
{ yyval.ysym = yyvsp[0].ysym;	yyval.ysym->tokenSize = 0;;
    break;}
case 74:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 75:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 79:
{ joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 80:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 82:
{	/* encode_decode_statement */
		joinSymbols (&yyval.ysym, yyvsp[-9].ysym, yyvsp[-8].ysym, yyvsp[-7].ysym, yyvsp[-6].ysym, yyvsp[-5].ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 83:
{ joinSymbols (&yyval.ysym, yyvsp[-8].ysym, yyvsp[-7].ysym, yyvsp[-6].ysym, yyvsp[-5].ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 87:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 88:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 93:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);;
    break;}
case 94:
{if (nonkeyRecordNumber)
			{YACC_SYMBOL	*pys;
			
			pys = createToken (", REC = ");
			joinSymbols (&yyval.ysym, yyvsp[-1].ysym, pys, nonkeyRecordNumber, yyvsp[0].ysym, NP);
			nonkeyRecordNumber = 0;
			}
		else
			joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 95:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 96:
{nonkeyRecordNumber = 0;
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 97:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 98:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 99:
{nonkeyRecordNumber = yyvsp[0].ysym;
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, NP);
		;
    break;}
case 100:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 101:
{ joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		nonkeyRecordNumber = 0;
		;
    break;}
case 102:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 103:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP) ;;
    break;}
case 104:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 105:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 106:
{  /* Include a module in default text library  */
		YACC_SYMBOL				*dotI;
		char			*pc;
	
		if (dollarInFileName (yyvsp[-3].ysym))
			{yyvsp[-5].ysym->number = COMMENT_STATEMENT_OUT;
			joinSymbols (&yyval.ysym, yyvsp[-5].ysym, yyvsp[-3].ysym, yyvsp[-1].ysym, NP);
			}
		else
			{dotI = createToken (".i");
			dotI->statementCharNo = yyvsp[-2].ysym->statementCharNo;
			dotI->printWithNextToken = 1;
			strlwr (yyvsp[-3].ysym->token);
			joinSymbols (&yyval.ysym, yyvsp[-5].ysym, yyvsp[-3].ysym, dotI, yyvsp[-1].ysym, NP);
			includeFromLibrary (yyvsp[-3].ysym->token);
			}
		;
    break;}
case 107:
{  /* Include a module from a specified library */
		
		YACC_SYMBOL				*dotI;
		char			*pc;
	
		if (dollarInFileName (yyvsp[-3].ysym))
			{yyvsp[-6].ysym->number = COMMENT_STATEMENT_OUT;
			joinSymbols (&yyval.ysym, yyvsp[-6].ysym, yyvsp[-3].ysym, yyvsp[-1].ysym, NP);
			}
		else
			{dotI = createToken (".i");
			dotI->statementCharNo = yyvsp[-2].ysym->statementCharNo;
			strcpy (dotI->token, ".i");
			strlwr (yyvsp[-3].ysym->token);
			joinSymbols (&yyval.ysym, yyvsp[-6].ysym, yyvsp[-3].ysym, dotI, yyvsp[-1].ysym, NP);
			includeFromLibrary (yyvsp[-3].ysym->token);
			}
		;
    break;}
case 108:
{  /* include a file */

		if (dollarInFileName (yyvsp[-2].ysym))
			{yyvsp[-3].ysym->number = COMMENT_STATEMENT_OUT;
			}
		else
			{if ( !strcmp ("forioerr.i", yyvsp[-2].ysym->token) )
				forioerrIncluded = 1;
			strlwr (yyvsp[-2].ysym->token);
			pushFile (yyvsp[-2].ysym->token);
			}
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
		;
    break;}
case 109:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 110:
{
		pushDoLevel (atoi (yyvsp[-2].ysym->token));
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
		;
    break;}
case 111:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);;
    break;}
case 119:
{ joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 120:
{/* arg_list */ yyval.ysym = yyvsp[0].ysym; 
		testAlternateReturn (yyvsp[0].ysym);;
    break;}
case 121:
{
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		LAL(yyvsp[-2].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 122:
{
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		LAL(yyvsp[-2].ysym, (YACC_SYMBOL *) 1, (YACC_SYMBOL *)1, NP);
		;
    break;}
case 123:
{
		LAL (yyvsp[-3].ysym, (YACC_SYMBOL *) 1, yyvsp[0].ysym, NP);
		testAlternateReturn (yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 124:
{
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		LAL(yyvsp[-1].ysym, (YACC_SYMBOL *) 1, (YACC_SYMBOL *) 1, NP);
		;
    break;}
case 125:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		testAlternateReturn (yyvsp[0].ysym);
		LAL(yyvsp[-2].ysym, (YACC_SYMBOL *) 1, (YACC_SYMBOL *) 1, yyvsp[0].ysym, NP);
		;
    break;}
case 126:
{
		int		newV;
		if (yyvsp[-1].ysym->arithType == ENAT_CHAR)
			{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
			yyvsp[-3].ysym->arithType = yyvsp[-1].ysym->arithType;
			yyvsp[-3].ysym->arithSize = yyvsp[-1].ysym->arithSize;}
		else
			yyval.ysym = yyvsp[-1].ysym;
		;
    break;}
case 127:
{ /* paren_ref */
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		processParenRef (yyvsp[-3].ysym, yyvsp[-1].ysym);
		;
    break;}
case 128:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		processParenRef (yyvsp[-2].ysym, 0);
		;
    break;}
case 129:
{YACC_SYMBOL	*py;
		
		py = createToken ("");
		py->number = MISSING_ARG;
		joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		LAL(py, (YACC_SYMBOL *)1, yyvsp[-1].ysym, NP);
		processParenRef (yyvsp[-4].ysym, py);
		;
    break;}
case 130:
{YACC_SYMBOL	*py;
		
		py = createToken ("");
		py->number = MISSING_ARG;
		joinSymbols (&yyval.ysym, yyvsp[-5].ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		LAL(py, yyvsp[-2].ysym, (YACC_SYMBOL *) 1, NP);
		processParenRef (yyvsp[-5].ysym, py);
		;
    break;}
case 131:
{YACC_SYMBOL	*py;
		
		py = createToken ("");
		py->number = MISSING_ARG;
		joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		LAL(yyvsp[-2].ysym, (YACC_SYMBOL *) 1, NP);
		processParenRef (yyvsp[-4].ysym, yyvsp[-2].ysym);
		;
    break;}
case 132:
{ /* expression */
	int		newVar;
	
	yyval.ysym = yyvsp[0].ysym;
	processLocalSymbol (yyvsp[0].ysym, &newVar);;
    break;}
case 134:
{
		int		newVar;
		SAP (yyvsp[-1].ysym, yyvsp[0].ysym)
		processLocalSymbol (yyvsp[0].ysym, &newVar);
		processUnaryOp (yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 135:
{
		SAP (yyvsp[-1].ysym, yyvsp[0].ysym)
		processUnaryOp (yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 136:
{
		SAP (yyvsp[-1].ysym, yyvsp[0].ysym)
		processUnaryOp (yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 137:
{
		SAP (yyvsp[-3].ysym, yyvsp[-1].ysym)
		processUnaryOp (yyvsp[-3].ysym, yyvsp[-1].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 138:
{
		SAP (yyvsp[-2].ysym, yyvsp[0].ysym)
		yyvsp[-2].ysym->constantValue = yyvsp[-1].ysym->constantValue;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 139:
{
		processBinaryOp (yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 140:
{
		processBinaryOp (yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 141:
{ joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 142:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 143:
{
		processBinaryOp (yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 144:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 148:
{
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 149:
{
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 150:
{
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 151:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 152:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 159:
{yyvsp[-2].ysym->arithSize += yyvsp[-1].ysym->arithSize;
		yyvsp[-2].ysym->arithType = ENAT_CHAR;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 160:
{yyvsp[-1].ysym->arithType = ENAT_CHAR;
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 161:
{yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_CHAR;
		;
    break;}
case 163:
{yyvsp[-1].ysym->arithSize += yyvsp[0].ysym->arithSize;
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 164:
{yyvsp[-5].ysym->arithSize = yyvsp[-3].ysym->arithSize + yyvsp[-1].ysym->arithSize;
		joinSymbols (&yyval.ysym, yyvsp[-5].ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 165:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 166:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 167:
{yyvsp[-5].ysym->arithSize = yyvsp[-3].ysym->arithSize + yyvsp[-1].ysym->arithSize;
		joinSymbols (&yyval.ysym, yyvsp[-5].ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 168:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 169:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 170:
{ /* literal: INTEGER_CONSTANT */ yyval.ysym=yyvsp[0].ysym; ;
    break;}
case 173:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
	;
    break;}
case 174:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_BYTE;
		;
    break;}
case 175:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_LOGICAL;
		;
    break;}
case 176:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_INT;
		;
    break;}
case 177:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_REAL;
		;
    break;}
case 178:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_DOUBLE;
		;
    break;}
case 179:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_COMPLEX;
		;
    break;}
case 180:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_DOUBLE_COMPLEX;
		;
    break;}
case 181:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithType = ENAT_CHAR;
		;
    break;}
case 183:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 185:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 186:
{int			first,
						last;
		YACC_SYMBOL		*ps;
		VARIABLE_TYPE	vt;

		vt.type = yyvsp[-3].ysym->arithType;
		vt.size = yyvsp[-3].ysym->arithSize;
		for (ps=yyvsp[-1].ysym;	ps;	ps=ps->argListLink)
			{first = (ps->constantValue)>>8;
			last = (ps->constantValue) & 0xff;
			if (first)
				implicitRangeAssign (implicitType, &vt, first, last);
			else
				implicitLetterAssign (implicitType, &vt, last);
			applyImplicit ();
			if ( ! (currentProcedureToken->storageClass & ENSC_EXPLICIT_TYPE) )
				{currentProcedureToken->arithType = vt.type;
				currentProcedureToken->arithSize = vt.size;
				}
			}
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); 
		;
    break;}
case 188:
{LAL (yyvsp[-2].ysym, yyvsp[0].ysym, NP);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 189:
{
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->constantValue = tolower (*(yyvsp[0].ysym->token));
		;
    break;}
case 190:
{int l=tolower(*(yyvsp[-2].ysym->token)), h=tolower (*(yyvsp[0].ysym->token)),c=l<<8+h;
		yyvsp[-2].ysym->constantValue = ( (tolower(*(yyvsp[-2].ysym->token)))<<8)+tolower (*(yyvsp[0].ysym->token));
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 191:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 192:
{yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->arithSize = defaultVariableSize (yyvsp[0].ysym->arithType);
		;
    break;}
case 193:
{yyvsp[-2].ysym->arithSize = atoi (yyvsp[0].ysym->token);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 194:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-4].ysym->arithSize = yyvsp[-1].ysym->constantValue;
		;
    break;}
case 195:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-4].ysym->arithSize = CONFORMING_SIZE;
		;
    break;}
case 196:
{/* EQUIVALENCE*/joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP) ;;
    break;}
case 197:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);;
    break;}
case 198:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 199:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 201:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);;
    break;}
case 204:
{/*DIMENSION*/joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 206:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 207:
{int		newVar;
	VARIABLE_DEFINITION		*pv;
	
	/* array_declarator */
	pv = processLocalSymbol (yyvsp[-3].ysym, &newVar);
	pv->type = ENVT_DIMENSIONED_VAR;
	pv->dimension = yyvsp[-1].ysym->dimensionLink;
	joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 209:
{DIMENSION_DEFINITION	**ppd,
								*pd;
		YACC_SYMBOL				*first, *next;
		first=yyvsp[-2].ysym; next=yyvsp[0].ysym;		/* for debugging only */
	/* Link dimension_element to the end of dimension_list */
		for (ppd=&(yyvsp[-2].ysym->dimensionLink), pd=yyvsp[-2].ysym->dimensionLink;	pd;	)
			{
			ppd=(DIMENSION_DEFINITION **)(&(pd->nextDim));
			pd = (DIMENSION_DEFINITION *)(pd->nextDim);
			}
		(*ppd) = (DIMENSION_DEFINITION *)(yyvsp[0].ysym->dimensionLink);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
 		 ;
    break;}
case 210:
{	/* dimension_element */
		yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->dimensionLink = defineSimpleDimension (yyvsp[0].ysym->constantValue);;
    break;}
case 211:
{yyvsp[-2].ysym->dimensionLink = defineComplexDimension (yyvsp[-2].ysym->constantValue,
			yyvsp[0].ysym->constantValue);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 213:
{yyval.ysym = yyvsp[0].ysym;
		getParameterValue (yyvsp[0].ysym);
		;
    break;}
case 214:
{processBinaryOp (yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 215:
{getParameterValue (yyvsp[0].ysym);
		processBinaryOp (yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 216:
{processUnaryOp (yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP)
		;
    break;}
case 217:
{getParameterValue (yyvsp[0].ysym);
		processUnaryOp (yyvsp[-1].ysym, yyvsp[0].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP)
		;
    break;}
case 218:
{/* type_definition_statement
		note that the followint types are used in type_definition_statement:
			type_variable_list extended_type_variable_item type_variable_item
	*/
	processTypeList (yyvsp[-1].ysym, yyvsp[-2].ysym);
	joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
	;
    break;}
case 220:
{/*type_variable_list*/joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 222:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 225:
{yyvsp[-2].ysym->arithSize = yyvsp[0].ysym->constantValue;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		;
    break;}
case 226:
{
		yyvsp[-2].ysym->arithSize = atoi (yyvsp[0].ysym->token);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 227:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-4].ysym->arithSize = yyvsp[-1].ysym->constantValue;
		;
    break;}
case 228:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-4].ysym->arithSize = CONFORMING_SIZE;
		;
    break;}
case 230:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 232:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 237:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  
		processCommonList (yyvsp[-1].ysym);
		;
    break;}
case 238:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  
		processCommonList (yyvsp[-2].ysym);
		processCommonList (yyvsp[-1].ysym);
		;
    break;}
case 239:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 240:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 242:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 243:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 244:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 248:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP); ;
    break;}
case 249:
{VARIABLE_TYPE		*vt;
		
		vt = &(implicitType[tolower(*(yyvsp[-1].ysym->token)) - 'a']);
		yyvsp[-1].ysym->arithType = vt->type;
		if ( !yyvsp[-1].ysym->arithSize)
			yyvsp[-1].ysym->arithSize = vt->size;
		currentProcedureToken->arithType = yyvsp[-1].ysym->arithType;
		currentProcedureToken->arithSize = yyvsp[-1].ysym->arithSize;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 250:
{yyvsp[-1].ysym->arithType = yyvsp[-3].ysym->arithType;
		if ( !yyvsp[-1].ysym->arithSize)
			yyvsp[-1].ysym->arithSize = yyvsp[-3].ysym->arithSize;
		yyvsp[-1].ysym->storageClass |= ENSC_EXPLICIT_TYPE;
		currentProcedureToken->storageClass = yyvsp[-1].ysym->storageClass;
		currentProcedureToken->arithType = yyvsp[-1].ysym->arithType;
		currentProcedureToken->arithSize = yyvsp[-1].ysym->arithSize;
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 251:
{yyval.ysym = yyvsp[0].ysym;
		yyvsp[0].ysym->variableType = ENVT_FUNCTION;
		setProcedureToken (yyvsp[0].ysym,0 );
		;
    break;}
case 252:
{yyvsp[-3].ysym->argListLink = yyvsp[-1].ysym;
		yyvsp[-3].ysym->variableType = ENVT_FUNCTION;
		setProcedureToken (yyvsp[-3].ysym, yyvsp[-1].ysym);
		joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 253:
{
		yyvsp[-2].ysym->variableType = ENVT_FUNCTION;
		setProcedureToken (yyvsp[-2].ysym, 0);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 255:
{yyvsp[-2].ysym->arithSize = atoi (yyvsp[0].ysym->token);
		yyvsp[-2].ysym->storageClass |= ENSC_EXPLICIT_TYPE;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 256:
{yyvsp[-4].ysym->arithSize = CONFORMING_SIZE;
		yyvsp[-4].ysym->storageClass |= ENSC_EXPLICIT_TYPE;
		joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym,yyvsp[0].ysym, NP); ;
    break;}
case 258:
{LAL (yyvsp[-2].ysym, yyvsp[0].ysym, NP);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 259:
{int		newVar;
		
		yyval.ysym = yyvsp[0].ysym;
		processLocalSymbol (yyvsp[0].ysym, &newVar);
		;
    break;}
case 260:
{yyval.ysym = yyvsp[0].ysym; 
		yyvsp[0].ysym->arithType = ENAT_ALTERNATE_RETURN;
		yyvsp[0].ysym->storageClass |= ENSC_EXPLICIT_TYPE;
    break;}
case 263:
{ /* subroutine_statement  */
		VARIABLE_DEFINITION		*pv;
		
		yyvsp[-4].ysym->variableType = ENVT_SUBROUTINE;
		
		setProcedureToken (yyvsp[-4].ysym, yyvsp[-2].ysym);
		
		joinSymbols (&yyval.ysym, yyvsp[-5].ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 264:
{
		VARIABLE_DEFINITION		*pv;
		yyvsp[-1].ysym->variableType = ENVT_SUBROUTINE;
		setProcedureToken (yyvsp[-1].ysym, 0);
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 265:
{
		VARIABLE_DEFINITION		*pv;
		yyvsp[-3].ysym->variableType = ENVT_SUBROUTINE;
		setProcedureToken (yyvsp[-3].ysym, 0);
		joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 266:
{ /* namelist_statement */
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 267:
{joinSymbols (&yyval.ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 268:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 269:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 270:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);  ;
    break;}
case 272:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
/*		processParameterList ($1, 0);*/
		;
    break;}
case 273:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);
/*		processParameterList ($1, 1); */
		;
    break;}
case 274:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-2].ysym->storageClass |= ENSC_PARAMETER;
		processParameterItem (yyvsp[-2].ysym, yyvsp[0].ysym, 1);  ;
    break;}
case 275:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-2].ysym->storageClass |= ENSC_PARAMETER;
		processParameterItem (yyvsp[-2].ysym, yyvsp[0].ysym, 1);  ;
    break;}
case 276:
{  /* vax_parameter_list */ joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-2].ysym->storageClass |= ENSC_PARAMETER;
		processParameterItem (yyvsp[-2].ysym, yyvsp[0].ysym, 0);
		  ;
    break;}
case 277:
{joinSymbols (&yyval.ysym, yyvsp[-4].ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, yyvsp[0].ysym, NP);
		yyvsp[-2].ysym->storageClass |= ENSC_PARAMETER;
		processParameterItem (yyvsp[-2].ysym, yyvsp[0].ysym, 0);
		;
    break;}
case 278:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 279:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 280:
{joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 281:
{joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  ;
    break;}
case 282:
{VARIABLE_DEFINITION	*pv;
		
		pv = processParenRef (yyvsp[-1].ysym, 0);
		pv->type = ENVT_SUBROUTINE;
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 283:
{
		 joinSymbols (&yyval.ysym, yyvsp[-3].ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP); ;
    break;}
case 284:
{
	/*	This version of the DATA statement is probably all that is required.
		I include the first form because I was almost finished with the 
		description when I realized it is probably not needed.  I leave the
		first form in the grammer just in case it might be helpful
		some time.  In any event, it is not executed as long as the lexer
		only generates PASS_TEXT tokens after seeing a DATA statement */
		joinSymbols (&yyval.ysym, yyvsp[-2].ysym, yyvsp[-1].ysym, NP);  
		;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */


  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}


/*	|DATA data_specification END_OF_STATEMENT
		{ joinSymbols (&$$, $1, NP);  }
	;

data_specification: data_item_list data_value_list
	| data_specification data_item_list data_value_list
	| data_specification COMMA data_item_list data_value_list
	;

data_item_list: data_element
	|data_element COMMA data_element
	;

data_element: VARIABLE_NAME
	| VARIABLE_NAME L_PAREN dimension_list R_PAREN
	| data_implied_do
	;

data_implied_do: L_PAREN data_item_list COMMA VARIABLE_NAME EQUALS
		VARIABLE_NAME COMMA VARIABLE_NAME R_PAREN
	| L_PAREN data_item_list COMMA VARIABLE_NAME EQUALS VARIABLE_NAME
		COMMA VARIABLE_NAME COMMA VARIABLE_NAME R_PAREN
	;


data_value_list: DATA_VALUE
	{ $$ = $1;
	}
	;
*/

/* ***************************** checkArgs ********************** */
static int checkArgs (char **ppch)
{char		*pch;


pch = *ppch;
if ( !strcmp (pch, "-D") )
	{yydebug = 1;
	return 1;
	}
if ( !strcmp (pch, "-G") )
	{generateGlobalData = 1;
	return 1;
	}
if ( !strcmp (pch, "-M") )
	{generateMakeDependencies = 1;
	makeDependencyFile = fopen ("makeDependencyFile", "w");
	return 1;
	}
if ( !strncmp (pch, "-I", 2))
	{int			retVal;
	
	retVal = 1;
	pch += 2;
	if ( !*pch)
		{pch = *(ppch+1);
		retVal = 2;
		}
	addIncludeSegment (pch);
	return retVal;
	}
if ( !strncmp ("-T", pch, 2) )
	{if ( !stricmp ("vax", pch+2) )
		{targetSystem = ENTS_VAX;
		littleEndian = 1;
		return 1;
		}
	}
return 0;
}

/* *************************** endOfStatementProc ********************* */
void endOfStatementProc ( YACC_SYMBOL *topToken)
{
/* subtle trap:  if the ending statement of a do loop is an enddo 
	then blockIndentLevel will be decremented twice
*/
if (doNestLevel && (currentStatementNo == doEndStack[doNestLevel-1]) )
	{--doNestLevel;
 	if (topToken->number != END_DO_STATEMENT)
		--blockIndentLevel;
	}
printStatement (topToken, currentStatementNo, yyout);
lexerEndOfStatementProc ();
heapFree (&tokenHeap, 0);
heapFree (&commentHeap, 0);
return;
}

/* ***************************** ignoreStatement ************************* */
static void ignoreStatement (void)
{
lexerEndOfStatementProc ();
heapFree (&tokenHeap, 0);
heapFree (&commentHeap, 0);
return;

}

/* **************************** includeFromLibrary ******************* */
static void includeFromLibrary (char *baseName)
{
char		name[250];

strcpy (name, baseName);
strcat (name, ".i");
pushFile (name);
}

/* ****************************** initializeVariable ********************** */
void    initializeVariable (VARIABLE_DEFINITION *pv)
{
int	i;
pv->type = ENVT_SCALAR;
i = tolower (*(pv->name) ) - 'a';
pv->arithType = implicitType[i].type;
pv->variableSize = implicitType[i].size;
pv->dimension = 0;
pv->commonOffset = -1;
pv->argumentOrCommonLink = 0;
pv->commonLink = 0;
return;
}

/* ****************************** initParser ***************************** */
static void initParser (void)
{
VARIABLE_TYPE	defaultInt = {ENAT_INT,4},
				defaultReal = {ENAT_REAL, 4};

heapInit (&commentHeap, COMMENT_DATA_SIZE, commentData);
heapInit (&tokenHeap, TOKEN_DATA_SIZE, tokenData);
implicitRangeAssign (implicitType, &defaultReal, 'a', 'z');
implicitRangeAssign (implicitType, &defaultInt, 'i', 'n');
dependencyCharsOnCurrentLine = 0;
resetLocalSymbols ( );
currentProcedureVar = 0;
procedureDeclarationPending = 0;
return;
}

/* ****************************** yyerror **************************** */
void yyerror (char *msg)
{
char		buff[150];


lexerErrorProc ();
sprintf (buff, "%s; %s on  line %d \n", currentFileName, msg, lineNo);
printf (buff);
fprintf (errorFile, buff);
return;
}

/* ******************************* yylex **************************** */
/* This beastie is supplied as an intermediate layer between the parser and
   the real lexer.  Certain items in the source file such as comment lines
   are handled by the lexer.  After this item is processed, the desire is
   to return yylex ().  However, this could cause a stack overflow if the
   source file had a great many consecutive comment lines.  The solution
   I have found is to have the lexer return IGNORE_THIS_TOKEN after 
   processing a comment.  When my version of yylex sees this return value
   it immediately calls forlex.
*/
int yylex (void)
{static int	retVal;
static int		END_OF_STATEMENT_returned;
static int		inputIsComplete;

if (inputIsComplete)
	{inputIsComplete = 0;
	return 0;
	}
/* Must force excatly one END_OF_STATEMENT return when end of file 
	is reached */
if (EOFRead)
	{EOFRead = 0;
	if ( !includeDepth)
		inhibitOutput = 0;
	else
		inhibitOutput = 1;
	return retVal;
	}
if (filePushed)
	{filePushed = 0;
	inhibitOutput = 1;
	}

l4:

retVal = forlex ();
if ( !retVal)
	{if (END_OF_STATEMENT_returned)
		{inputIsComplete = 0;
		return 0;
		}
	inputIsComplete = 1;
	END_OF_STATEMENT_returned = 1;
	return END_OF_STATEMENT;
	}
if (retVal == END_OF_STATEMENT)
	END_OF_STATEMENT_returned = 1;
else
	END_OF_STATEMENT_returned = 0;

if ( EOFRead)
	{
	return END_OF_STATEMENT;
	}
if (IGNORE_THIS_TOKEN == retVal)
	goto l4;
return retVal;
}

/* ****************************** popDoLevel ************************ *\
static int popDoLevel (void)
static void pushDoLevel (int statementNo)
{
if ( !doNestLevel--)
	{printf ("do nest stack underflow\n");
	exit (1);
	}
return doEndStack[doNestLevel];
}

/* ****************************** processBinaryOp ************************ */
static void processBinaryOp (YACC_SYMBOL *l, YACC_SYMBOL *op, YACC_SYMBOL *r)
{
if ( (l->arithType != ENAT_INT) || (r->arithType != ENAT_INT) )
	return;
if (op->number == ADD_OP)
	{if (strchr (op->token, '+'))
		l->constantValue += r->constantValue;
	else
		l->constantValue -= r->constantValue;
	}
else if (op->number == MUL_OP)
	{if (strchr (op->token, '*'))
		l->constantValue *= r->constantValue;
	else
		{if (r->constantValue)
			l->constantValue /= r->constantValue;
		}
	}
else if (op->number == EXP_OP)
	{long		x;
	int			i;
	
	for (x=1, i=0;	i<r->constantValue;	++i)
		x *= r->constantValue;
	}
l->arithSize = max (l->arithSize, r->arithSize);
return;
}

/* ****************************** processUnaryOp ************************ */
static void processUnaryOp (YACC_SYMBOL *op, YACC_SYMBOL *r)
{

if ( (op->number != ADD_OP) || (r->arithType != ENAT_INT) )
	return;
	{if ( strchr (op->token, '+'))
		op->constantValue = r->constantValue;
	else
		op->constantValue = -r->constantValue;
	}
op->arithType = r->arithType;
op->arithSize = r->arithSize;
return;
}

/* ****************************** pushDoLevel ************************ */
static void pushDoLevel (int statementNo)
{
if (doNestLevel >= MAX_DO_NEST_LEVEL)
	{printf ("do nest stack overflow\n");
	exit (1);
	}
doEndStack[doNestLevel++] = statementNo;
return;
}

/* ****************************** setProcedureToken *********************** */
static void setProcedureToken (YACC_SYMBOL *proc, YACC_SYMBOL *arg)

/*	Porcessing explicit procedure definitions (i.e. resulting from a SUBROUTINE
	or a FUNCTION statement) can cause a spurious error message if the 
	procedure has been defined previously.  This results from the fact that
	IMPLICIT and type definition statements which follow the defining statement
	can change the type of the formal arguments.  So is the parser defines the
	procedure immediately after the end of the defining statement, the types and
	sizes of the formal arguments may not agree with previous usage.

	One solution to this problem would be to defer processing the defining
	statement until all type declarations are processed, and then perform
	normal procedure processing.  However, the normal processing requires the
	use of YACC_TOKEN s, and these structures do not persist across statements..

	My solution is to copy the procedure's YACC_SYMBOL to a static structure, 
	then to form a linked list of the VARIABLE_DEFINITION s which correspond
	to the formal arguments of the procedure.  The field constantValue in each
	VARIABLE_DEFINITION is set to the index of the variable in the procesure's
	formal parameter list.  The storageClass is set to ENSC_DUMMY_VARIABLE,
	Finally, a flag is set which will
	cause the parser to define the procedure when type specification statments
	have all been processed.
*/

{
VARIABLE_DEFINITION		**nextLink,
						*currentVar;
YACC_SYMBOL				*currentTok;
int						newVar,
						varIndex;

if ( !arg)
	{pcurrentArgVar = 0;
	goto l4;
	}
nextLink = &pcurrentArgVar;
for (currentTok = arg, varIndex=0;	currentTok;	
		currentTok = currentTok->argListLink, ++varIndex)
	{currentVar = processLocalSymbol (currentTok, &newVar);
	currentVar->constantValue = varIndex;
	currentVar->storageClass |= ENSC_DUMMY_VARIABLE;
	*nextLink = currentVar;
	nextLink = (VARIABLE_DEFINITION **)(&(currentVar->argumentOrCommonLink));
	}
currentVar->argumentOrCommonLink = 0;

l4:

memcpy ((void *)currentProcedureToken, (void *)proc, sizeof (YACC_SYMBOL) + 100);
procedureDeclarationPending = 1;

}

/* **************************** testAlternateReturn *********************** */
static void testAlternateReturn (YACC_SYMBOL *pys)
{
if ( *(pys->token)=='*' && (pys->next) && (pys->next->number==INTEGER_CONSTANT) )
	{pys->arithSize = 0;
	pys->arithType = ENAT_ALTERNATE_RETURN;
	}
return;
}


/* ****************************** unknownFileType ************************* */
static void unknownFileType (char *name)
{
printf ("%s is not a recognized file type\n", name);
return;
}

static char	currentFile[255];

/* ******************************* main ******************************** */
int main (int argc, char **argv)
{
char		*newExtent,
			**parg,
			*pch,
			*pch2;
int			baseLength,
			directoryNameLength,
			i;
char		*outputFileName;
char		*errorFileName;
FILE		*sourceNames;

initAllSymbols ();
currentProcedureToken = (YACC_SYMBOL *) malloc (sizeof(YACC_SYMBOL)+100);
yydebug = 0;
if (argc <2)
	{
	printf ("usage: vax2unix file\n	file is the FORTRAN file to convert\n");
	exit (1);
	}
parg = argv + 1;
while (i=checkArgs (parg))
	parg += i;
processIncludeEnvironment ();
if (**parg == '@')
	{
	sourceNames = fopen (*parg+1, "r");
	if ( !sourceNames )
		{printf ("Can't open indirect file\n");
		exit (1);
		}
	}
else sourceNames = 0;

l4:

if ( !sourceNames)
	strcpy (currentFile, *parg);
else
	{

l6:

	pch = fgets (currentFile, 255, sourceNames);
	if (pch)
		{if (*pch == ';')
			goto l6;
	/* ignore the newline char */
		currentFile[strlen(currentFile)-1] = 0;
		}
	else
		goto l10;
	}
if (currentSourceDir)
	{free ( (void *) currentSourceDir);
	currentSourceDir = 0;
	}
for (pch = currentFile;	pch;	)
	{pch2 = pch;
	pch = strpbrk (pch2+1, "\\/");
	}
directoryNameLength = pch2 - currentFile;
if (directoryNameLength++)
	{currentSourceDir = (char *) malloc (directoryNameLength + 1);
	strncpy (currentSourceDir, currentFile, directoryNameLength);
	*(currentSourceDir+directoryNameLength) = 0;
	}
else
	currentSourceDir = 0;
pch = strrchr (currentFile, '.');
baseLength = pch-currentFile;
if ( !pch)
	{unknownFileType (currentFileName);
	goto l8;
	}
newExtent = 0;
if ( !strnicmp (pch, ".INC", 4) )
	newExtent = ".i";
else if ( !strnicmp (pch, ".FOR", 4) )
	newExtent = ".f";
if ( !newExtent)
	{unknownFileType (currentFile);
	goto l8;
	}
yyin = fopen (currentFile, "r");
if ( !yyin)
	{printf ("Open failure on source\n");
	exit (1);
	}
currentFileName = (char *) malloc (strlen (currentFile));
strcpy (currentFileName, currentFile);
lineNo = 1;
outputFileName = (char *) malloc (baseLength + 3);
errorFileName = (char *) malloc (baseLength + 5);
strncpy (outputFileName, currentFileName, baseLength);
strcpy (outputFileName+baseLength, newExtent);
strncpy (errorFileName, currentFileName, baseLength);
strcpy (errorFileName+baseLength, ".err");
yyout = fopen (outputFileName, "wb");
errorFile = fopen (errorFileName, "w");
if (makeDependencyFile)
	fprintf (makeDependencyFile, "\n");

initLexer ();
initParser ();
yyparse ();

free ( (void *) outputFileName);
free ( (void *) errorFileName);
forioerrIncluded = 0;
fclose (yyin);
fclose (yyout);
fclose (errorFile);

l8:
if (sourceNames)
	goto l4;
++parg;
if (*parg)
	goto l4;

l10:

if (makeDependencyFile)
	fclose (makeDependencyFile);
if (generateGlobalData)
	writeGlobals ();
return 0;
}
